# Dependable System

`sleepdeprivedtable`

---

## 🧩 Chunk 1: Introduction to Dependable Systems

### 🔍 What is Dependability?
Dependability is **a measure of how much you can trust a system**.  
A dependable system is one that:
- Works as expected (reliable)
- Is available when needed (available)
- Does not harm people or data (safe)
- Is protected from unauthorized access (secure)

🧠 **Analogy:**  
If a car is dependable, it starts, runs safely, and locks securely — same logic applies to computer systems.

---

### ⚖️ Dependability vs. Detailed Functionality

| **Dependability** | **Detailed Functionality** |
|--------------------|----------------------------|
| Availability, reliability, safety, security | Extra or specialized features |
| Prioritizes trustworthiness | Prioritizes new capabilities |

💡 Users prefer a reliable system over one that’s flashy but prone to errors.

---

### ⚠️ Why Dependability Matters
- Failures affect many users.
- Users reject unreliable systems.
- Costs of failure can be massive.
- Data loss can cripple organizations.

---

### ⚙️ Dependable Systems Engineering
Dependability is **not only a software issue**.  
It includes:
- Hardware reliability
- Human operation
- Organizational policies

➡️ Requires a **sociotechnical systems perspective**.

---

### 🧩 Real-World Example
- **Airplane systems:** pilots, hardware, and software all need to work in sync.
- **Hospital systems:** must run reliably; human and technical components are both vital.

---

### 🌱 Summary
Dependability is the **trust factor** of computing systems.  
You can add more features later, but you can’t patch trust once broken.

---

🖥️ **Dependable System = (Software + Hardware + Human)**  
that stays:
- 🕐 Available  
- 🔁 Reliable  
- 🛡️ Safe  
- 🔒 Secure  
- 💪 Resilient  

---

## 🧩 Chunk 2: Causes and Dimensions of Dependability

### ⚙️ Causes of Failure

| **Type** | **Cause** | **Examples** |
|-----------|------------|--------------|
| 🧱 Hardware Failure | Physical component malfunction | Overheating CPU, damaged RAM, aging parts |
| 💻 Software Failure | Design or coding errors | Logic bugs, incorrect specifications |
| 🧍 Operational Failure | User or operator mistakes | Misconfigurations, accidental deletions |

🧠 **Note:** Human and software issues are often linked — unclear design leads to misuse.

---

### 🧩 The Five Dimensions of Dependability

| **Dimension** | **Meaning** | **Example** |
|----------------|-------------|-------------|
| 🕐 Availability | System is running when needed | Hospital server uptime |
| 🔁 Reliability | Performs correctly over time | ATM dispensing right amount |
| 🛡️ Safety | Avoids causing harm | Emergency stop on robots |
| 🔒 Security | Protects against attacks | Banking encryption |
| 💪 Resilience | Keeps operating under failure | Website switching to backup server |

---

### ⚙️ Other Related Properties

| **Property** | **Meaning** |
|---------------|-------------|
| 🔧 Repairability | Failures can be fixed fast |
| 🔄 Maintainability | System adapts easily to new needs |
| 💬 Error Tolerance | Handles user mistakes gracefully |

---

### 💸 Dependability vs. Cost

> “The higher the dependability required, the higher the cost.”

High-dependability systems (aviation, healthcare, banking) require:
- Extensive testing  
- Redundant design  
- Strict safety standards  

---

### 🚗 Analogy: Car Dependability

| **Car Feature** | **Dependability Aspect** |
|------------------|--------------------------|
| Reliable engine | Reliability |
| Always starts | Availability |
| Airbags, brakes | Safety |
| Alarm, locks | Security |
| Still drives with a broken sensor | Resilience |

---

### 🌱 Summary
Dependability ≠ perfection.  
It means the system can **resist, recover, and endure** when things go wrong.

---

## 🧩 Chunk 3: Sociotechnical Systems

### 🧠 What Are Sociotechnical Systems?
A **sociotechnical system** combines:
- Hardware
- Software
- Human users
- Processes
- Organizational and social context

> Dependability = Technical Quality × Human/Organizational Alignment

---

### ⚙️ Why Purely Technical Thinking Isn’t Enough
Even technically perfect software can fail if:
- Users misunderstand it  
- Processes are unclear  
- Regulations are ignored  

Dependability requires human and organizational cooperation.

---
### 🧩 Software–Hardware Interdependence

> “Software and the Hardware are interdependent.  
> Software alone = abstraction.  
> Hardware alone = inert devices.  
> Together = system that performs computations.”

### 🧠 Software Alone = Abstraction
- Software is logic or instructions — it *represents* processes but doesn’t act.
- Like a **blueprint**: meaningful, but not functional without a machine.

💡 Example:  
A mobile app sitting in a folder isn’t doing anything until the phone runs it.

---

### ⚙️ Hardware Alone = Inert Devices
- Hardware is physical components with no purpose until guided by software.
- Like a **car without a driver** — all power, no direction.

💡 Example:  
A smartphone without an OS can’t interpret inputs or show output.

---

### ⚡ Together = A Computing System
- Software provides **meaning and control**.  
- Hardware provides **execution and action**.  
- Together, they create **computations** — real operations that achieve results.

💡 Analogy:  
Software = recipe 🧾  
Hardware = kitchen tools 🍳  
→ Together = an actual cooked meal 🍲

---

### 🌱 Why It Matters
Dependability depends on **coordination**:
- Software must fit hardware limits.
- Hardware must support software reliability.
A dependable system is one where both sides **cooperate seamlessly**.




### 🧩 Layers of a Sociotechnical System

| **Layer** | **Description** | **Example** |
|------------|----------------|-------------|
| ⚙️ Equipment | Physical devices | Servers, routers |
| 🧠 Operating System | Hardware control | Linux, Windows |
| 🧩 Communications & Data Management | Middleware linking components | APIs, databases |
| 💻 Applications | Provide user-facing functions | Online booking, hospital records |
| 🏢 Business Processes | Workflows the system supports | Loan approval, patient discharge |
| 👥 Organization | Culture, management, policies | IT governance, staff training |
| ⚖️ Social / Regulatory | Laws and standards | GDPR, HIPAA |

---

### ✈️ Example: Airline Reservation System

| **Layer** | **Example** |
|------------|-------------|
| Equipment | Airport servers |
| Middleware | Flight data systems |
| Application | Booking website |
| Business Process | Check-in workflow |
| Organization | Airline procedures |
| Social | Aviation laws |

A failure in one layer can disrupt the whole system.

---

## ⚖️ Design Principles for Dependability

### 🧩 1. Contain Failures Within Their Layer
**Goal:** Prevent small failures from spreading.  
**How:**  
- Design modular systems with clear boundaries.  
- Handle errors locally before they propagate.  
- Use isolation (containers, sandboxing).  
**Example:**  
A UI crash shouldn’t bring down the backend server.

💬 *Analogy:* A short circuit in one room shouldn’t blackout the entire house.

---

### 🧩 2. Understand Dependencies Between Layers
**Goal:** Know how failures ripple through the system.  
**How:**  
- Document and visualize dependencies.  
- Monitor inter-layer data flows.  
- Avoid tight coupling between components.  
**Example:**  
If the currency service fails, the loan calculator should gracefully degrade.

💬 *Analogy:* If one gear turns, know which others move — otherwise you won’t see the stress points.

---

### 🧩 3. Build Checks and Recovery Support Across Layers
**Goal:** Detect and recover from failures automatically.  
**How:**  
- Add monitoring and error recovery at multiple layers.  
- Use rollbacks, backups, and fault tolerance mechanisms.  
- Test fault scenarios regularly.  
**Example:**  
Databases rollback failed transactions; servers use watchdog timers to restart crashed services.

💬 *Analogy:* Safety nets stacked under each other — if one fails, another catches you.

---

### 🌱 Summary
Dependability = Contain + Understand + Recover.  
It’s not about preventing all failures — it’s about **ensuring they never grow beyond control.**


---

### 🌱 Summary
Dependability is **sociotechnical**: it depends on people, technology, and context all working together.

---

## 🧩 Chunk 4: Designing and Building Dependable Systems

### ⚙️ Goal
Design systems that **anticipate, prevent, and recover** from failures.

---

### 🧩 Key Strategies

| **Approach** | **Meaning** | **Goal** |
|---------------|-------------|----------|
| 1️⃣ Avoid errors | Prevent design/spec mistakes early | Prevention |
| 2️⃣ Verify & validate | Testing and code reviews | Detection |
| 3️⃣ Add fault tolerance | Keep system working despite failure | Survival |
| 4️⃣ Add protection | Defend against attacks | Defense |
| 5️⃣ Proper configuration | Adapt to environment | Optimization |
| 6️⃣ Detect cyberattacks | Identify and respond to intrusions | Security |
| 7️⃣ Enable recovery | Restore operations fast | Resilience |

---

### 🧩 Redundancy and Diversity

| **Concept** | **Meaning** | **Example** |
|--------------|-------------|--------------|
| 🔁 Redundancy | Spare components take over if one fails | Server clusters, RAID |
| 🌈 Diversity | Different designs for the same function | Two antiviruses from different vendors |

💬 **Together:** Redundancy ensures continuity; diversity avoids shared failure modes.

---

### ⚖️ The Simplicity Principle
> Keep software simple, spend more on verification.

- Complexity increases risk.
- Critical systems prioritize *clarity over features*.

✈️ Example: Airplane control software — minimal interface, maximum reliability.

---

### 🏛️ Regulation and Compliance

| **Aspect** | **Meaning** |
|-------------|-------------|
| Economic context | Companies compete, but safety standards limit risks |
| Government role | Sets laws for safety/security |
| Regulators | Enforce compliance, issue penalties |
| Standards | ISO 27001, HIPAA, FAA safety standards |

Dependability = **technical + legal + ethical accountability**.

---

### 🧱 Dependable Design Pyramid
```
	       Recovery & Resilience
	     Fault Tolerance & Security
	 Verification / Validation / Testing
    Clear Specification & Error Prevention

```


---

### 🌱 Summary
Dependable systems **expect things to go wrong** — and stay stable anyway.
They survive, recover, and remain trustworthy under stress.

---

## 🧩 Chunk 5: Dependable Processes

### 🧠 What Are Dependable Processes?
Structured software processes that reduce errors and produce reliable, auditable outcomes.

---

### 🧩 Why They Matter
- Fewer errors → fewer failures.  
- Provide **evidence** of best practices.  
- Ensure **consistency** across teams and projects.  
- Build **trust** in safety-critical domains.

🧠 Analogy: A flight checklist — ensures consistency even under stress.

---

### ⚙️ Key Requirements

| **Requirement** | **Meaning** | **Goal** |
|------------------|-------------|-----------|
| 🧾 Explicitly Defined | Documented, traceable process model | Transparency |
| 🔁 Repeatable | Works for different teams/projects | Consistency |

---

### 🧩 Attributes of Dependable Processes

| **Attribute** | **Description** |
|----------------|----------------|
| 👀 Auditable | Compliance can be verified externally |
| 🎯 Diverse | Uses multiple error-checking techniques |
| 🧩 Documentable | All steps and results are recorded |
| 🧱 Robust | Can recover from internal process errors |
| ⚙️ Standardized | Aligned with accepted development standards |

---

### 🧩 Support Processes

| **Process** | **Purpose** |
|--------------|-------------|
| 🧪 Quality Management | Ensures defined standards are met |
| 🔄 Change Management | Controls updates, avoids wrong component releases |

---

### 🧠 Example
Medical device software:
- Requirements traced to tests  
- Peer reviews for all changes  
- Version logs maintained for audits  

---

### 🌱 Summary
Dependability begins with **how** software is built.  
Reliable products come from reliable processes — not chance.

---
## 🧩 Chunk 6: Formal Methods

### 🧠 Definition
**Formal methods** use **mathematics** to design and verify software systems.  
They aim to prove, not just test, that software behaves correctly.

| **Concept** | **Meaning** |
|--------------|-------------|
| 🧩 Formal | Based on precise mathematical notation |
| 📐 Methods | Systematic ways to specify and verify behavior |

---

### 🧮 Why Use Formal Methods?
- Detect design errors early.  
- Eliminate ambiguity from requirements.  
- Offer mathematical assurance for safety-critical systems.  

⚠️ Limitations:
- Costly, complex, requires math expertise.  
- Used mainly where failure = catastrophe.

---

### 🧩 Where They’re Used

| **Domain** | **Example** |
|-------------|-------------|
| 🚄 Train Control | Paris Metro automation |
| 💳 Banking Systems | Smart card validation |
| ✈️ Flight Control | Autopilot software |
| 🪟 OS/Driver Verification | Microsoft driver checks |

---

### 🧩 Types of Formal Methods

| **Type** | **Focus** | **Example** |
|-----------|-----------|-------------|
| 🧾 Program Proving | Proves code matches spec | Cryptographic functions |
| 🔄 Refinement-Based Development | Stepwise model → verified code | Paris Metro systems |
| 🧮 Model Checking | Exhaustively explore all states | Chip and OS verification |

💬 *Program proving* → mathematical guarantee  
💬 *Refinement* → systematic development  
💬 *Model checking* → automated safety verification

---

### 🧠 Example
Railway signal control:
1. Model train and signal states.  
2. Use model checking to ensure no two trains share a track.  
3. Only then implement.

---

### 🌱 Summary
Formal methods **prove correctness** rather than just test for it.  
They’re essential for high-risk, high-stakes systems — where trust must be mathematically earned.

